// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: edr_event.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_edr_5fevent_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_edr_5fevent_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_edr_5fevent_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_edr_5fevent_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_edr_5fevent_2eproto;
class CreateFileEvent;
struct CreateFileEventDefaultTypeInternal;
extern CreateFileEventDefaultTypeInternal _CreateFileEvent_default_instance_;
class EdrEventMessage;
struct EdrEventMessageDefaultTypeInternal;
extern EdrEventMessageDefaultTypeInternal _EdrEventMessage_default_instance_;
class EdrEventMessage_SubMessage;
struct EdrEventMessage_SubMessageDefaultTypeInternal;
extern EdrEventMessage_SubMessageDefaultTypeInternal _EdrEventMessage_SubMessage_default_instance_;
class EdrRiskEvent;
struct EdrRiskEventDefaultTypeInternal;
extern EdrRiskEventDefaultTypeInternal _EdrRiskEvent_default_instance_;
class NetConEvent;
struct NetConEventDefaultTypeInternal;
extern NetConEventDefaultTypeInternal _NetConEvent_default_instance_;
class ProcessStart;
struct ProcessStartDefaultTypeInternal;
extern ProcessStartDefaultTypeInternal _ProcessStart_default_instance_;
class ReNameFileEvent;
struct ReNameFileEventDefaultTypeInternal;
extern ReNameFileEventDefaultTypeInternal _ReNameFileEvent_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CreateFileEvent* Arena::CreateMaybeMessage<::CreateFileEvent>(Arena*);
template<> ::EdrEventMessage* Arena::CreateMaybeMessage<::EdrEventMessage>(Arena*);
template<> ::EdrEventMessage_SubMessage* Arena::CreateMaybeMessage<::EdrEventMessage_SubMessage>(Arena*);
template<> ::EdrRiskEvent* Arena::CreateMaybeMessage<::EdrRiskEvent>(Arena*);
template<> ::NetConEvent* Arena::CreateMaybeMessage<::NetConEvent>(Arena*);
template<> ::ProcessStart* Arena::CreateMaybeMessage<::ProcessStart>(Arena*);
template<> ::ReNameFileEvent* Arena::CreateMaybeMessage<::ReNameFileEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class EdrRiskEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EdrRiskEvent) */ {
 public:
  inline EdrRiskEvent() : EdrRiskEvent(nullptr) {}
  ~EdrRiskEvent() override;
  explicit PROTOBUF_CONSTEXPR EdrRiskEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdrRiskEvent(const EdrRiskEvent& from);
  EdrRiskEvent(EdrRiskEvent&& from) noexcept
    : EdrRiskEvent() {
    *this = ::std::move(from);
  }

  inline EdrRiskEvent& operator=(const EdrRiskEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdrRiskEvent& operator=(EdrRiskEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EdrRiskEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdrRiskEvent* internal_default_instance() {
    return reinterpret_cast<const EdrRiskEvent*>(
               &_EdrRiskEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EdrRiskEvent& a, EdrRiskEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(EdrRiskEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdrRiskEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EdrRiskEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EdrRiskEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EdrRiskEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EdrRiskEvent& from) {
    EdrRiskEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdrRiskEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EdrRiskEvent";
  }
  protected:
  explicit EdrRiskEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcinfosFieldNumber = 6,
    kDesFieldNumber = 1,
    kProcinfoFieldNumber = 2,
    kEventinfoFieldNumber = 4,
    kAgentipFieldNumber = 7,
    kHostnameFieldNumber = 8,
    kEventidFieldNumber = 3,
    kActionFieldNumber = 5,
  };
  // repeated bytes procinfos = 6;
  int procinfos_size() const;
  private:
  int _internal_procinfos_size() const;
  public:
  void clear_procinfos();
  const std::string& procinfos(int index) const;
  std::string* mutable_procinfos(int index);
  void set_procinfos(int index, const std::string& value);
  void set_procinfos(int index, std::string&& value);
  void set_procinfos(int index, const char* value);
  void set_procinfos(int index, const void* value, size_t size);
  std::string* add_procinfos();
  void add_procinfos(const std::string& value);
  void add_procinfos(std::string&& value);
  void add_procinfos(const char* value);
  void add_procinfos(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& procinfos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_procinfos();
  private:
  const std::string& _internal_procinfos(int index) const;
  std::string* _internal_add_procinfos();
  public:

  // string des = 1;
  void clear_des();
  const std::string& des() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_des(ArgT0&& arg0, ArgT... args);
  std::string* mutable_des();
  PROTOBUF_NODISCARD std::string* release_des();
  void set_allocated_des(std::string* des);
  private:
  const std::string& _internal_des() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_des(const std::string& value);
  std::string* _internal_mutable_des();
  public:

  // bytes procinfo = 2;
  void clear_procinfo();
  const std::string& procinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_procinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_procinfo();
  PROTOBUF_NODISCARD std::string* release_procinfo();
  void set_allocated_procinfo(std::string* procinfo);
  private:
  const std::string& _internal_procinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_procinfo(const std::string& value);
  std::string* _internal_mutable_procinfo();
  public:

  // bytes eventinfo = 4;
  void clear_eventinfo();
  const std::string& eventinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eventinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eventinfo();
  PROTOBUF_NODISCARD std::string* release_eventinfo();
  void set_allocated_eventinfo(std::string* eventinfo);
  private:
  const std::string& _internal_eventinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eventinfo(const std::string& value);
  std::string* _internal_mutable_eventinfo();
  public:

  // string agentip = 7;
  void clear_agentip();
  const std::string& agentip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agentip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agentip();
  PROTOBUF_NODISCARD std::string* release_agentip();
  void set_allocated_agentip(std::string* agentip);
  private:
  const std::string& _internal_agentip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agentip(const std::string& value);
  std::string* _internal_mutable_agentip();
  public:

  // string hostname = 8;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // int32 eventid = 3;
  void clear_eventid();
  int32_t eventid() const;
  void set_eventid(int32_t value);
  private:
  int32_t _internal_eventid() const;
  void _internal_set_eventid(int32_t value);
  public:

  // int32 action = 5;
  void clear_action();
  int32_t action() const;
  void set_action(int32_t value);
  private:
  int32_t _internal_action() const;
  void _internal_set_action(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EdrRiskEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> procinfos_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr des_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr procinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eventinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agentip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    int32_t eventid_;
    int32_t action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_edr_5fevent_2eproto;
};
// -------------------------------------------------------------------

class EdrEventMessage_SubMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EdrEventMessage.SubMessage) */ {
 public:
  inline EdrEventMessage_SubMessage() : EdrEventMessage_SubMessage(nullptr) {}
  ~EdrEventMessage_SubMessage() override;
  explicit PROTOBUF_CONSTEXPR EdrEventMessage_SubMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdrEventMessage_SubMessage(const EdrEventMessage_SubMessage& from);
  EdrEventMessage_SubMessage(EdrEventMessage_SubMessage&& from) noexcept
    : EdrEventMessage_SubMessage() {
    *this = ::std::move(from);
  }

  inline EdrEventMessage_SubMessage& operator=(const EdrEventMessage_SubMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdrEventMessage_SubMessage& operator=(EdrEventMessage_SubMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EdrEventMessage_SubMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdrEventMessage_SubMessage* internal_default_instance() {
    return reinterpret_cast<const EdrEventMessage_SubMessage*>(
               &_EdrEventMessage_SubMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EdrEventMessage_SubMessage& a, EdrEventMessage_SubMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EdrEventMessage_SubMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdrEventMessage_SubMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EdrEventMessage_SubMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EdrEventMessage_SubMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EdrEventMessage_SubMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EdrEventMessage_SubMessage& from) {
    EdrEventMessage_SubMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdrEventMessage_SubMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EdrEventMessage.SubMessage";
  }
  protected:
  explicit EdrEventMessage_SubMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventinfoFieldNumber = 3,
    kEventtypeFieldNumber = 1,
    kTimesFieldNumber = 2,
  };
  // bytes eventinfo = 3;
  void clear_eventinfo();
  const std::string& eventinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eventinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eventinfo();
  PROTOBUF_NODISCARD std::string* release_eventinfo();
  void set_allocated_eventinfo(std::string* eventinfo);
  private:
  const std::string& _internal_eventinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eventinfo(const std::string& value);
  std::string* _internal_mutable_eventinfo();
  public:

  // int32 eventtype = 1;
  void clear_eventtype();
  int32_t eventtype() const;
  void set_eventtype(int32_t value);
  private:
  int32_t _internal_eventtype() const;
  void _internal_set_eventtype(int32_t value);
  public:

  // int32 times = 2;
  void clear_times();
  int32_t times() const;
  void set_times(int32_t value);
  private:
  int32_t _internal_times() const;
  void _internal_set_times(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EdrEventMessage.SubMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eventinfo_;
    int32_t eventtype_;
    int32_t times_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_edr_5fevent_2eproto;
};
// -------------------------------------------------------------------

class EdrEventMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EdrEventMessage) */ {
 public:
  inline EdrEventMessage() : EdrEventMessage(nullptr) {}
  ~EdrEventMessage() override;
  explicit PROTOBUF_CONSTEXPR EdrEventMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdrEventMessage(const EdrEventMessage& from);
  EdrEventMessage(EdrEventMessage&& from) noexcept
    : EdrEventMessage() {
    *this = ::std::move(from);
  }

  inline EdrEventMessage& operator=(const EdrEventMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdrEventMessage& operator=(EdrEventMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EdrEventMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdrEventMessage* internal_default_instance() {
    return reinterpret_cast<const EdrEventMessage*>(
               &_EdrEventMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EdrEventMessage& a, EdrEventMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EdrEventMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdrEventMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EdrEventMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EdrEventMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EdrEventMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EdrEventMessage& from) {
    EdrEventMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdrEventMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EdrEventMessage";
  }
  protected:
  explicit EdrEventMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EdrEventMessage_SubMessage SubMessage;

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // repeated .EdrEventMessage.SubMessage msg = 1;
  int msg_size() const;
  private:
  int _internal_msg_size() const;
  public:
  void clear_msg();
  ::EdrEventMessage_SubMessage* mutable_msg(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EdrEventMessage_SubMessage >*
      mutable_msg();
  private:
  const ::EdrEventMessage_SubMessage& _internal_msg(int index) const;
  ::EdrEventMessage_SubMessage* _internal_add_msg();
  public:
  const ::EdrEventMessage_SubMessage& msg(int index) const;
  ::EdrEventMessage_SubMessage* add_msg();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EdrEventMessage_SubMessage >&
      msg() const;

  // @@protoc_insertion_point(class_scope:EdrEventMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EdrEventMessage_SubMessage > msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_edr_5fevent_2eproto;
};
// -------------------------------------------------------------------

class ProcessStart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProcessStart) */ {
 public:
  inline ProcessStart() : ProcessStart(nullptr) {}
  ~ProcessStart() override;
  explicit PROTOBUF_CONSTEXPR ProcessStart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessStart(const ProcessStart& from);
  ProcessStart(ProcessStart&& from) noexcept
    : ProcessStart() {
    *this = ::std::move(from);
  }

  inline ProcessStart& operator=(const ProcessStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessStart& operator=(ProcessStart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessStart& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessStart* internal_default_instance() {
    return reinterpret_cast<const ProcessStart*>(
               &_ProcessStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProcessStart& a, ProcessStart& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessStart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessStart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessStart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessStart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessStart& from) {
    ProcessStart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessStart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProcessStart";
  }
  protected:
  explicit ProcessStart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImagePathFieldNumber = 3,
    kHashFieldNumber = 4,
    kCompanyFieldNumber = 5,
    kProductFieldNumber = 6,
    kOriginalFileFieldNumber = 7,
    kUserFieldNumber = 8,
    kSIDFieldNumber = 9,
    kCommandLineFieldNumber = 10,
    kCurrentDirectoryFieldNumber = 11,
    kSignerFieldNumber = 13,
    kProcessGuidFieldNumber = 14,
    kParentProcessGuidFieldNumber = 15,
    kProcFileIdFieldNumber = 16,
    kSignerNameFieldNumber = 17,
    kFileguidFieldNumber = 22,
    kUtcTimeFieldNumber = 1,
    kProcessIdFieldNumber = 2,
    kTerminalSessionIdFieldNumber = 12,
    kIntegrityFieldNumber = 18,
    kCreateTimeFieldNumber = 19,
    kFileSizeFieldNumber = 20,
    kSignStatusFieldNumber = 21,
    kStartTypeFieldNumber = 23,
  };
  // string ImagePath = 3;
  void clear_imagepath();
  const std::string& imagepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imagepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imagepath();
  PROTOBUF_NODISCARD std::string* release_imagepath();
  void set_allocated_imagepath(std::string* imagepath);
  private:
  const std::string& _internal_imagepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imagepath(const std::string& value);
  std::string* _internal_mutable_imagepath();
  public:

  // string Hash = 4;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // string Company = 5;
  void clear_company();
  const std::string& company() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_company(ArgT0&& arg0, ArgT... args);
  std::string* mutable_company();
  PROTOBUF_NODISCARD std::string* release_company();
  void set_allocated_company(std::string* company);
  private:
  const std::string& _internal_company() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_company(const std::string& value);
  std::string* _internal_mutable_company();
  public:

  // string Product = 6;
  void clear_product();
  const std::string& product() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product();
  PROTOBUF_NODISCARD std::string* release_product();
  void set_allocated_product(std::string* product);
  private:
  const std::string& _internal_product() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product(const std::string& value);
  std::string* _internal_mutable_product();
  public:

  // string OriginalFile = 7;
  void clear_originalfile();
  const std::string& originalfile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalfile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalfile();
  PROTOBUF_NODISCARD std::string* release_originalfile();
  void set_allocated_originalfile(std::string* originalfile);
  private:
  const std::string& _internal_originalfile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalfile(const std::string& value);
  std::string* _internal_mutable_originalfile();
  public:

  // string User = 8;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string SID = 9;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // string CommandLine = 10;
  void clear_commandline();
  const std::string& commandline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_commandline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_commandline();
  PROTOBUF_NODISCARD std::string* release_commandline();
  void set_allocated_commandline(std::string* commandline);
  private:
  const std::string& _internal_commandline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commandline(const std::string& value);
  std::string* _internal_mutable_commandline();
  public:

  // string CurrentDirectory = 11;
  void clear_currentdirectory();
  const std::string& currentdirectory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currentdirectory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currentdirectory();
  PROTOBUF_NODISCARD std::string* release_currentdirectory();
  void set_allocated_currentdirectory(std::string* currentdirectory);
  private:
  const std::string& _internal_currentdirectory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currentdirectory(const std::string& value);
  std::string* _internal_mutable_currentdirectory();
  public:

  // string Signer = 13;
  void clear_signer();
  const std::string& signer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* signer);
  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(const std::string& value);
  std::string* _internal_mutable_signer();
  public:

  // string ProcessGuid = 14;
  void clear_processguid();
  const std::string& processguid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processguid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processguid();
  PROTOBUF_NODISCARD std::string* release_processguid();
  void set_allocated_processguid(std::string* processguid);
  private:
  const std::string& _internal_processguid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processguid(const std::string& value);
  std::string* _internal_mutable_processguid();
  public:

  // string ParentProcessGuid = 15;
  void clear_parentprocessguid();
  const std::string& parentprocessguid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parentprocessguid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parentprocessguid();
  PROTOBUF_NODISCARD std::string* release_parentprocessguid();
  void set_allocated_parentprocessguid(std::string* parentprocessguid);
  private:
  const std::string& _internal_parentprocessguid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parentprocessguid(const std::string& value);
  std::string* _internal_mutable_parentprocessguid();
  public:

  // string ProcFileId = 16;
  void clear_procfileid();
  const std::string& procfileid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_procfileid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_procfileid();
  PROTOBUF_NODISCARD std::string* release_procfileid();
  void set_allocated_procfileid(std::string* procfileid);
  private:
  const std::string& _internal_procfileid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_procfileid(const std::string& value);
  std::string* _internal_mutable_procfileid();
  public:

  // string SignerName = 17;
  void clear_signername();
  const std::string& signername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signername();
  PROTOBUF_NODISCARD std::string* release_signername();
  void set_allocated_signername(std::string* signername);
  private:
  const std::string& _internal_signername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signername(const std::string& value);
  std::string* _internal_mutable_signername();
  public:

  // string fileguid = 22;
  void clear_fileguid();
  const std::string& fileguid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fileguid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fileguid();
  PROTOBUF_NODISCARD std::string* release_fileguid();
  void set_allocated_fileguid(std::string* fileguid);
  private:
  const std::string& _internal_fileguid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fileguid(const std::string& value);
  std::string* _internal_mutable_fileguid();
  public:

  // int32 UtcTime = 1;
  void clear_utctime();
  int32_t utctime() const;
  void set_utctime(int32_t value);
  private:
  int32_t _internal_utctime() const;
  void _internal_set_utctime(int32_t value);
  public:

  // int32 ProcessId = 2;
  void clear_processid();
  int32_t processid() const;
  void set_processid(int32_t value);
  private:
  int32_t _internal_processid() const;
  void _internal_set_processid(int32_t value);
  public:

  // int32 TerminalSessionId = 12;
  void clear_terminalsessionid();
  int32_t terminalsessionid() const;
  void set_terminalsessionid(int32_t value);
  private:
  int32_t _internal_terminalsessionid() const;
  void _internal_set_terminalsessionid(int32_t value);
  public:

  // int32 Integrity = 18;
  void clear_integrity();
  int32_t integrity() const;
  void set_integrity(int32_t value);
  private:
  int32_t _internal_integrity() const;
  void _internal_set_integrity(int32_t value);
  public:

  // int32 CreateTime = 19;
  void clear_createtime();
  int32_t createtime() const;
  void set_createtime(int32_t value);
  private:
  int32_t _internal_createtime() const;
  void _internal_set_createtime(int32_t value);
  public:

  // int32 FileSize = 20;
  void clear_filesize();
  int32_t filesize() const;
  void set_filesize(int32_t value);
  private:
  int32_t _internal_filesize() const;
  void _internal_set_filesize(int32_t value);
  public:

  // int32 SignStatus = 21;
  void clear_signstatus();
  int32_t signstatus() const;
  void set_signstatus(int32_t value);
  private:
  int32_t _internal_signstatus() const;
  void _internal_set_signstatus(int32_t value);
  public:

  // int32 StartType = 23;
  void clear_starttype();
  int32_t starttype() const;
  void set_starttype(int32_t value);
  private:
  int32_t _internal_starttype() const;
  void _internal_set_starttype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProcessStart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imagepath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr company_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalfile_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commandline_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currentdirectory_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processguid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parentprocessguid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr procfileid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fileguid_;
    int32_t utctime_;
    int32_t processid_;
    int32_t terminalsessionid_;
    int32_t integrity_;
    int32_t createtime_;
    int32_t filesize_;
    int32_t signstatus_;
    int32_t starttype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_edr_5fevent_2eproto;
};
// -------------------------------------------------------------------

class NetConEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NetConEvent) */ {
 public:
  inline NetConEvent() : NetConEvent(nullptr) {}
  ~NetConEvent() override;
  explicit PROTOBUF_CONSTEXPR NetConEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetConEvent(const NetConEvent& from);
  NetConEvent(NetConEvent&& from) noexcept
    : NetConEvent() {
    *this = ::std::move(from);
  }

  inline NetConEvent& operator=(const NetConEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetConEvent& operator=(NetConEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetConEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetConEvent* internal_default_instance() {
    return reinterpret_cast<const NetConEvent*>(
               &_NetConEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NetConEvent& a, NetConEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(NetConEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetConEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetConEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetConEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetConEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetConEvent& from) {
    NetConEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetConEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NetConEvent";
  }
  protected:
  explicit NetConEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessGuidFieldNumber = 2,
    kUtcTimeFieldNumber = 1,
    kProtocolFieldNumber = 3,
    kSourceIpFieldNumber = 4,
    kSourcePortFieldNumber = 5,
    kDestinationIpFieldNumber = 6,
    kDestinationPortFieldNumber = 7,
  };
  // string ProcessGuid = 2;
  void clear_processguid();
  const std::string& processguid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processguid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processguid();
  PROTOBUF_NODISCARD std::string* release_processguid();
  void set_allocated_processguid(std::string* processguid);
  private:
  const std::string& _internal_processguid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processguid(const std::string& value);
  std::string* _internal_mutable_processguid();
  public:

  // int32 UtcTime = 1;
  void clear_utctime();
  int32_t utctime() const;
  void set_utctime(int32_t value);
  private:
  int32_t _internal_utctime() const;
  void _internal_set_utctime(int32_t value);
  public:

  // int32 Protocol = 3;
  void clear_protocol();
  int32_t protocol() const;
  void set_protocol(int32_t value);
  private:
  int32_t _internal_protocol() const;
  void _internal_set_protocol(int32_t value);
  public:

  // fixed32 SourceIp = 4;
  void clear_sourceip();
  uint32_t sourceip() const;
  void set_sourceip(uint32_t value);
  private:
  uint32_t _internal_sourceip() const;
  void _internal_set_sourceip(uint32_t value);
  public:

  // fixed32 SourcePort = 5;
  void clear_sourceport();
  uint32_t sourceport() const;
  void set_sourceport(uint32_t value);
  private:
  uint32_t _internal_sourceport() const;
  void _internal_set_sourceport(uint32_t value);
  public:

  // fixed32 DestinationIp = 6;
  void clear_destinationip();
  uint32_t destinationip() const;
  void set_destinationip(uint32_t value);
  private:
  uint32_t _internal_destinationip() const;
  void _internal_set_destinationip(uint32_t value);
  public:

  // fixed32 DestinationPort = 7;
  void clear_destinationport();
  uint32_t destinationport() const;
  void set_destinationport(uint32_t value);
  private:
  uint32_t _internal_destinationport() const;
  void _internal_set_destinationport(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NetConEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processguid_;
    int32_t utctime_;
    int32_t protocol_;
    uint32_t sourceip_;
    uint32_t sourceport_;
    uint32_t destinationip_;
    uint32_t destinationport_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_edr_5fevent_2eproto;
};
// -------------------------------------------------------------------

class CreateFileEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CreateFileEvent) */ {
 public:
  inline CreateFileEvent() : CreateFileEvent(nullptr) {}
  ~CreateFileEvent() override;
  explicit PROTOBUF_CONSTEXPR CreateFileEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateFileEvent(const CreateFileEvent& from);
  CreateFileEvent(CreateFileEvent&& from) noexcept
    : CreateFileEvent() {
    *this = ::std::move(from);
  }

  inline CreateFileEvent& operator=(const CreateFileEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFileEvent& operator=(CreateFileEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFileEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFileEvent* internal_default_instance() {
    return reinterpret_cast<const CreateFileEvent*>(
               &_CreateFileEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateFileEvent& a, CreateFileEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFileEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFileEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFileEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFileEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateFileEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateFileEvent& from) {
    CreateFileEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFileEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CreateFileEvent";
  }
  protected:
  explicit CreateFileEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessGuidFieldNumber = 2,
    kFileNameFieldNumber = 3,
    kFileIDFieldNumber = 7,
    kFileHashFieldNumber = 10,
    kSignerFieldNumber = 11,
    kSignerNameFieldNumber = 12,
    kCompanyNameFieldNumber = 13,
    kOriginalFileFieldNumber = 14,
    kProductNameFieldNumber = 15,
    kUtcTimeFieldNumber = 1,
    kCreateTimeFieldNumber = 4,
    kCreateOptionsFieldNumber = 5,
    kDesiredAccessFieldNumber = 6,
    kFileSizeFieldNumber = 8,
    kSignStatusFieldNumber = 9,
  };
  // string ProcessGuid = 2;
  void clear_processguid();
  const std::string& processguid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processguid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processguid();
  PROTOBUF_NODISCARD std::string* release_processguid();
  void set_allocated_processguid(std::string* processguid);
  private:
  const std::string& _internal_processguid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processguid(const std::string& value);
  std::string* _internal_mutable_processguid();
  public:

  // string FileName = 3;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string FileID = 7;
  void clear_fileid();
  const std::string& fileid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fileid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fileid();
  PROTOBUF_NODISCARD std::string* release_fileid();
  void set_allocated_fileid(std::string* fileid);
  private:
  const std::string& _internal_fileid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fileid(const std::string& value);
  std::string* _internal_mutable_fileid();
  public:

  // string FileHash = 10;
  void clear_filehash();
  const std::string& filehash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filehash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filehash();
  PROTOBUF_NODISCARD std::string* release_filehash();
  void set_allocated_filehash(std::string* filehash);
  private:
  const std::string& _internal_filehash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filehash(const std::string& value);
  std::string* _internal_mutable_filehash();
  public:

  // string Signer = 11;
  void clear_signer();
  const std::string& signer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* signer);
  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(const std::string& value);
  std::string* _internal_mutable_signer();
  public:

  // string SignerName = 12;
  void clear_signername();
  const std::string& signername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signername();
  PROTOBUF_NODISCARD std::string* release_signername();
  void set_allocated_signername(std::string* signername);
  private:
  const std::string& _internal_signername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signername(const std::string& value);
  std::string* _internal_mutable_signername();
  public:

  // string CompanyName = 13;
  void clear_companyname();
  const std::string& companyname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_companyname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_companyname();
  PROTOBUF_NODISCARD std::string* release_companyname();
  void set_allocated_companyname(std::string* companyname);
  private:
  const std::string& _internal_companyname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_companyname(const std::string& value);
  std::string* _internal_mutable_companyname();
  public:

  // string OriginalFile = 14;
  void clear_originalfile();
  const std::string& originalfile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalfile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalfile();
  PROTOBUF_NODISCARD std::string* release_originalfile();
  void set_allocated_originalfile(std::string* originalfile);
  private:
  const std::string& _internal_originalfile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalfile(const std::string& value);
  std::string* _internal_mutable_originalfile();
  public:

  // string ProductName = 15;
  void clear_productname();
  const std::string& productname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_productname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_productname();
  PROTOBUF_NODISCARD std::string* release_productname();
  void set_allocated_productname(std::string* productname);
  private:
  const std::string& _internal_productname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productname(const std::string& value);
  std::string* _internal_mutable_productname();
  public:

  // int32 UtcTime = 1;
  void clear_utctime();
  int32_t utctime() const;
  void set_utctime(int32_t value);
  private:
  int32_t _internal_utctime() const;
  void _internal_set_utctime(int32_t value);
  public:

  // int32 CreateTime = 4;
  void clear_createtime();
  int32_t createtime() const;
  void set_createtime(int32_t value);
  private:
  int32_t _internal_createtime() const;
  void _internal_set_createtime(int32_t value);
  public:

  // int32 CreateOptions = 5;
  void clear_createoptions();
  int32_t createoptions() const;
  void set_createoptions(int32_t value);
  private:
  int32_t _internal_createoptions() const;
  void _internal_set_createoptions(int32_t value);
  public:

  // int32 DesiredAccess = 6;
  void clear_desiredaccess();
  int32_t desiredaccess() const;
  void set_desiredaccess(int32_t value);
  private:
  int32_t _internal_desiredaccess() const;
  void _internal_set_desiredaccess(int32_t value);
  public:

  // int32 FileSize = 8;
  void clear_filesize();
  int32_t filesize() const;
  void set_filesize(int32_t value);
  private:
  int32_t _internal_filesize() const;
  void _internal_set_filesize(int32_t value);
  public:

  // int32 SignStatus = 9;
  void clear_signstatus();
  int32_t signstatus() const;
  void set_signstatus(int32_t value);
  private:
  int32_t _internal_signstatus() const;
  void _internal_set_signstatus(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CreateFileEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processguid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fileid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filehash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr companyname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalfile_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr productname_;
    int32_t utctime_;
    int32_t createtime_;
    int32_t createoptions_;
    int32_t desiredaccess_;
    int32_t filesize_;
    int32_t signstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_edr_5fevent_2eproto;
};
// -------------------------------------------------------------------

class ReNameFileEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReNameFileEvent) */ {
 public:
  inline ReNameFileEvent() : ReNameFileEvent(nullptr) {}
  ~ReNameFileEvent() override;
  explicit PROTOBUF_CONSTEXPR ReNameFileEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReNameFileEvent(const ReNameFileEvent& from);
  ReNameFileEvent(ReNameFileEvent&& from) noexcept
    : ReNameFileEvent() {
    *this = ::std::move(from);
  }

  inline ReNameFileEvent& operator=(const ReNameFileEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReNameFileEvent& operator=(ReNameFileEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReNameFileEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReNameFileEvent* internal_default_instance() {
    return reinterpret_cast<const ReNameFileEvent*>(
               &_ReNameFileEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReNameFileEvent& a, ReNameFileEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ReNameFileEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReNameFileEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReNameFileEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReNameFileEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReNameFileEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReNameFileEvent& from) {
    ReNameFileEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReNameFileEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReNameFileEvent";
  }
  protected:
  explicit ReNameFileEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessGuidFieldNumber = 2,
    kOldPathFieldNumber = 3,
    kNewPathFieldNumber = 4,
    kFileSignerFieldNumber = 5,
    kFileIDFieldNumber = 6,
    kUtcTimeFieldNumber = 1,
  };
  // string ProcessGuid = 2;
  void clear_processguid();
  const std::string& processguid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processguid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processguid();
  PROTOBUF_NODISCARD std::string* release_processguid();
  void set_allocated_processguid(std::string* processguid);
  private:
  const std::string& _internal_processguid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processguid(const std::string& value);
  std::string* _internal_mutable_processguid();
  public:

  // string OldPath = 3;
  void clear_oldpath();
  const std::string& oldpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oldpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oldpath();
  PROTOBUF_NODISCARD std::string* release_oldpath();
  void set_allocated_oldpath(std::string* oldpath);
  private:
  const std::string& _internal_oldpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldpath(const std::string& value);
  std::string* _internal_mutable_oldpath();
  public:

  // string NewPath = 4;
  void clear_newpath();
  const std::string& newpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newpath();
  PROTOBUF_NODISCARD std::string* release_newpath();
  void set_allocated_newpath(std::string* newpath);
  private:
  const std::string& _internal_newpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newpath(const std::string& value);
  std::string* _internal_mutable_newpath();
  public:

  // string FileSigner = 5;
  void clear_filesigner();
  const std::string& filesigner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesigner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesigner();
  PROTOBUF_NODISCARD std::string* release_filesigner();
  void set_allocated_filesigner(std::string* filesigner);
  private:
  const std::string& _internal_filesigner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesigner(const std::string& value);
  std::string* _internal_mutable_filesigner();
  public:

  // string FileID = 6;
  void clear_fileid();
  const std::string& fileid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fileid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fileid();
  PROTOBUF_NODISCARD std::string* release_fileid();
  void set_allocated_fileid(std::string* fileid);
  private:
  const std::string& _internal_fileid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fileid(const std::string& value);
  std::string* _internal_mutable_fileid();
  public:

  // int32 UtcTime = 1;
  void clear_utctime();
  int32_t utctime() const;
  void set_utctime(int32_t value);
  private:
  int32_t _internal_utctime() const;
  void _internal_set_utctime(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReNameFileEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processguid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oldpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesigner_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fileid_;
    int32_t utctime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_edr_5fevent_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EdrRiskEvent

// string des = 1;
inline void EdrRiskEvent::clear_des() {
  _impl_.des_.ClearToEmpty();
}
inline const std::string& EdrRiskEvent::des() const {
  // @@protoc_insertion_point(field_get:EdrRiskEvent.des)
  return _internal_des();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdrRiskEvent::set_des(ArgT0&& arg0, ArgT... args) {
 
 _impl_.des_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EdrRiskEvent.des)
}
inline std::string* EdrRiskEvent::mutable_des() {
  std::string* _s = _internal_mutable_des();
  // @@protoc_insertion_point(field_mutable:EdrRiskEvent.des)
  return _s;
}
inline const std::string& EdrRiskEvent::_internal_des() const {
  return _impl_.des_.Get();
}
inline void EdrRiskEvent::_internal_set_des(const std::string& value) {
  
  _impl_.des_.Set(value, GetArenaForAllocation());
}
inline std::string* EdrRiskEvent::_internal_mutable_des() {
  
  return _impl_.des_.Mutable(GetArenaForAllocation());
}
inline std::string* EdrRiskEvent::release_des() {
  // @@protoc_insertion_point(field_release:EdrRiskEvent.des)
  return _impl_.des_.Release();
}
inline void EdrRiskEvent::set_allocated_des(std::string* des) {
  if (des != nullptr) {
    
  } else {
    
  }
  _impl_.des_.SetAllocated(des, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.des_.IsDefault()) {
    _impl_.des_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EdrRiskEvent.des)
}

// bytes procinfo = 2;
inline void EdrRiskEvent::clear_procinfo() {
  _impl_.procinfo_.ClearToEmpty();
}
inline const std::string& EdrRiskEvent::procinfo() const {
  // @@protoc_insertion_point(field_get:EdrRiskEvent.procinfo)
  return _internal_procinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdrRiskEvent::set_procinfo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.procinfo_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EdrRiskEvent.procinfo)
}
inline std::string* EdrRiskEvent::mutable_procinfo() {
  std::string* _s = _internal_mutable_procinfo();
  // @@protoc_insertion_point(field_mutable:EdrRiskEvent.procinfo)
  return _s;
}
inline const std::string& EdrRiskEvent::_internal_procinfo() const {
  return _impl_.procinfo_.Get();
}
inline void EdrRiskEvent::_internal_set_procinfo(const std::string& value) {
  
  _impl_.procinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* EdrRiskEvent::_internal_mutable_procinfo() {
  
  return _impl_.procinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* EdrRiskEvent::release_procinfo() {
  // @@protoc_insertion_point(field_release:EdrRiskEvent.procinfo)
  return _impl_.procinfo_.Release();
}
inline void EdrRiskEvent::set_allocated_procinfo(std::string* procinfo) {
  if (procinfo != nullptr) {
    
  } else {
    
  }
  _impl_.procinfo_.SetAllocated(procinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.procinfo_.IsDefault()) {
    _impl_.procinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EdrRiskEvent.procinfo)
}

// int32 eventid = 3;
inline void EdrRiskEvent::clear_eventid() {
  _impl_.eventid_ = 0;
}
inline int32_t EdrRiskEvent::_internal_eventid() const {
  return _impl_.eventid_;
}
inline int32_t EdrRiskEvent::eventid() const {
  // @@protoc_insertion_point(field_get:EdrRiskEvent.eventid)
  return _internal_eventid();
}
inline void EdrRiskEvent::_internal_set_eventid(int32_t value) {
  
  _impl_.eventid_ = value;
}
inline void EdrRiskEvent::set_eventid(int32_t value) {
  _internal_set_eventid(value);
  // @@protoc_insertion_point(field_set:EdrRiskEvent.eventid)
}

// bytes eventinfo = 4;
inline void EdrRiskEvent::clear_eventinfo() {
  _impl_.eventinfo_.ClearToEmpty();
}
inline const std::string& EdrRiskEvent::eventinfo() const {
  // @@protoc_insertion_point(field_get:EdrRiskEvent.eventinfo)
  return _internal_eventinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdrRiskEvent::set_eventinfo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.eventinfo_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EdrRiskEvent.eventinfo)
}
inline std::string* EdrRiskEvent::mutable_eventinfo() {
  std::string* _s = _internal_mutable_eventinfo();
  // @@protoc_insertion_point(field_mutable:EdrRiskEvent.eventinfo)
  return _s;
}
inline const std::string& EdrRiskEvent::_internal_eventinfo() const {
  return _impl_.eventinfo_.Get();
}
inline void EdrRiskEvent::_internal_set_eventinfo(const std::string& value) {
  
  _impl_.eventinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* EdrRiskEvent::_internal_mutable_eventinfo() {
  
  return _impl_.eventinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* EdrRiskEvent::release_eventinfo() {
  // @@protoc_insertion_point(field_release:EdrRiskEvent.eventinfo)
  return _impl_.eventinfo_.Release();
}
inline void EdrRiskEvent::set_allocated_eventinfo(std::string* eventinfo) {
  if (eventinfo != nullptr) {
    
  } else {
    
  }
  _impl_.eventinfo_.SetAllocated(eventinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eventinfo_.IsDefault()) {
    _impl_.eventinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EdrRiskEvent.eventinfo)
}

// int32 action = 5;
inline void EdrRiskEvent::clear_action() {
  _impl_.action_ = 0;
}
inline int32_t EdrRiskEvent::_internal_action() const {
  return _impl_.action_;
}
inline int32_t EdrRiskEvent::action() const {
  // @@protoc_insertion_point(field_get:EdrRiskEvent.action)
  return _internal_action();
}
inline void EdrRiskEvent::_internal_set_action(int32_t value) {
  
  _impl_.action_ = value;
}
inline void EdrRiskEvent::set_action(int32_t value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:EdrRiskEvent.action)
}

// repeated bytes procinfos = 6;
inline int EdrRiskEvent::_internal_procinfos_size() const {
  return _impl_.procinfos_.size();
}
inline int EdrRiskEvent::procinfos_size() const {
  return _internal_procinfos_size();
}
inline void EdrRiskEvent::clear_procinfos() {
  _impl_.procinfos_.Clear();
}
inline std::string* EdrRiskEvent::add_procinfos() {
  std::string* _s = _internal_add_procinfos();
  // @@protoc_insertion_point(field_add_mutable:EdrRiskEvent.procinfos)
  return _s;
}
inline const std::string& EdrRiskEvent::_internal_procinfos(int index) const {
  return _impl_.procinfos_.Get(index);
}
inline const std::string& EdrRiskEvent::procinfos(int index) const {
  // @@protoc_insertion_point(field_get:EdrRiskEvent.procinfos)
  return _internal_procinfos(index);
}
inline std::string* EdrRiskEvent::mutable_procinfos(int index) {
  // @@protoc_insertion_point(field_mutable:EdrRiskEvent.procinfos)
  return _impl_.procinfos_.Mutable(index);
}
inline void EdrRiskEvent::set_procinfos(int index, const std::string& value) {
  _impl_.procinfos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:EdrRiskEvent.procinfos)
}
inline void EdrRiskEvent::set_procinfos(int index, std::string&& value) {
  _impl_.procinfos_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:EdrRiskEvent.procinfos)
}
inline void EdrRiskEvent::set_procinfos(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.procinfos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:EdrRiskEvent.procinfos)
}
inline void EdrRiskEvent::set_procinfos(int index, const void* value, size_t size) {
  _impl_.procinfos_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:EdrRiskEvent.procinfos)
}
inline std::string* EdrRiskEvent::_internal_add_procinfos() {
  return _impl_.procinfos_.Add();
}
inline void EdrRiskEvent::add_procinfos(const std::string& value) {
  _impl_.procinfos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:EdrRiskEvent.procinfos)
}
inline void EdrRiskEvent::add_procinfos(std::string&& value) {
  _impl_.procinfos_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:EdrRiskEvent.procinfos)
}
inline void EdrRiskEvent::add_procinfos(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.procinfos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:EdrRiskEvent.procinfos)
}
inline void EdrRiskEvent::add_procinfos(const void* value, size_t size) {
  _impl_.procinfos_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:EdrRiskEvent.procinfos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EdrRiskEvent::procinfos() const {
  // @@protoc_insertion_point(field_list:EdrRiskEvent.procinfos)
  return _impl_.procinfos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EdrRiskEvent::mutable_procinfos() {
  // @@protoc_insertion_point(field_mutable_list:EdrRiskEvent.procinfos)
  return &_impl_.procinfos_;
}

// string agentip = 7;
inline void EdrRiskEvent::clear_agentip() {
  _impl_.agentip_.ClearToEmpty();
}
inline const std::string& EdrRiskEvent::agentip() const {
  // @@protoc_insertion_point(field_get:EdrRiskEvent.agentip)
  return _internal_agentip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdrRiskEvent::set_agentip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agentip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EdrRiskEvent.agentip)
}
inline std::string* EdrRiskEvent::mutable_agentip() {
  std::string* _s = _internal_mutable_agentip();
  // @@protoc_insertion_point(field_mutable:EdrRiskEvent.agentip)
  return _s;
}
inline const std::string& EdrRiskEvent::_internal_agentip() const {
  return _impl_.agentip_.Get();
}
inline void EdrRiskEvent::_internal_set_agentip(const std::string& value) {
  
  _impl_.agentip_.Set(value, GetArenaForAllocation());
}
inline std::string* EdrRiskEvent::_internal_mutable_agentip() {
  
  return _impl_.agentip_.Mutable(GetArenaForAllocation());
}
inline std::string* EdrRiskEvent::release_agentip() {
  // @@protoc_insertion_point(field_release:EdrRiskEvent.agentip)
  return _impl_.agentip_.Release();
}
inline void EdrRiskEvent::set_allocated_agentip(std::string* agentip) {
  if (agentip != nullptr) {
    
  } else {
    
  }
  _impl_.agentip_.SetAllocated(agentip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agentip_.IsDefault()) {
    _impl_.agentip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EdrRiskEvent.agentip)
}

// string hostname = 8;
inline void EdrRiskEvent::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& EdrRiskEvent::hostname() const {
  // @@protoc_insertion_point(field_get:EdrRiskEvent.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdrRiskEvent::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EdrRiskEvent.hostname)
}
inline std::string* EdrRiskEvent::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:EdrRiskEvent.hostname)
  return _s;
}
inline const std::string& EdrRiskEvent::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void EdrRiskEvent::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* EdrRiskEvent::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* EdrRiskEvent::release_hostname() {
  // @@protoc_insertion_point(field_release:EdrRiskEvent.hostname)
  return _impl_.hostname_.Release();
}
inline void EdrRiskEvent::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EdrRiskEvent.hostname)
}

// -------------------------------------------------------------------

// EdrEventMessage_SubMessage

// int32 eventtype = 1;
inline void EdrEventMessage_SubMessage::clear_eventtype() {
  _impl_.eventtype_ = 0;
}
inline int32_t EdrEventMessage_SubMessage::_internal_eventtype() const {
  return _impl_.eventtype_;
}
inline int32_t EdrEventMessage_SubMessage::eventtype() const {
  // @@protoc_insertion_point(field_get:EdrEventMessage.SubMessage.eventtype)
  return _internal_eventtype();
}
inline void EdrEventMessage_SubMessage::_internal_set_eventtype(int32_t value) {
  
  _impl_.eventtype_ = value;
}
inline void EdrEventMessage_SubMessage::set_eventtype(int32_t value) {
  _internal_set_eventtype(value);
  // @@protoc_insertion_point(field_set:EdrEventMessage.SubMessage.eventtype)
}

// int32 times = 2;
inline void EdrEventMessage_SubMessage::clear_times() {
  _impl_.times_ = 0;
}
inline int32_t EdrEventMessage_SubMessage::_internal_times() const {
  return _impl_.times_;
}
inline int32_t EdrEventMessage_SubMessage::times() const {
  // @@protoc_insertion_point(field_get:EdrEventMessage.SubMessage.times)
  return _internal_times();
}
inline void EdrEventMessage_SubMessage::_internal_set_times(int32_t value) {
  
  _impl_.times_ = value;
}
inline void EdrEventMessage_SubMessage::set_times(int32_t value) {
  _internal_set_times(value);
  // @@protoc_insertion_point(field_set:EdrEventMessage.SubMessage.times)
}

// bytes eventinfo = 3;
inline void EdrEventMessage_SubMessage::clear_eventinfo() {
  _impl_.eventinfo_.ClearToEmpty();
}
inline const std::string& EdrEventMessage_SubMessage::eventinfo() const {
  // @@protoc_insertion_point(field_get:EdrEventMessage.SubMessage.eventinfo)
  return _internal_eventinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdrEventMessage_SubMessage::set_eventinfo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.eventinfo_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EdrEventMessage.SubMessage.eventinfo)
}
inline std::string* EdrEventMessage_SubMessage::mutable_eventinfo() {
  std::string* _s = _internal_mutable_eventinfo();
  // @@protoc_insertion_point(field_mutable:EdrEventMessage.SubMessage.eventinfo)
  return _s;
}
inline const std::string& EdrEventMessage_SubMessage::_internal_eventinfo() const {
  return _impl_.eventinfo_.Get();
}
inline void EdrEventMessage_SubMessage::_internal_set_eventinfo(const std::string& value) {
  
  _impl_.eventinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* EdrEventMessage_SubMessage::_internal_mutable_eventinfo() {
  
  return _impl_.eventinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* EdrEventMessage_SubMessage::release_eventinfo() {
  // @@protoc_insertion_point(field_release:EdrEventMessage.SubMessage.eventinfo)
  return _impl_.eventinfo_.Release();
}
inline void EdrEventMessage_SubMessage::set_allocated_eventinfo(std::string* eventinfo) {
  if (eventinfo != nullptr) {
    
  } else {
    
  }
  _impl_.eventinfo_.SetAllocated(eventinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eventinfo_.IsDefault()) {
    _impl_.eventinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EdrEventMessage.SubMessage.eventinfo)
}

// -------------------------------------------------------------------

// EdrEventMessage

// repeated .EdrEventMessage.SubMessage msg = 1;
inline int EdrEventMessage::_internal_msg_size() const {
  return _impl_.msg_.size();
}
inline int EdrEventMessage::msg_size() const {
  return _internal_msg_size();
}
inline void EdrEventMessage::clear_msg() {
  _impl_.msg_.Clear();
}
inline ::EdrEventMessage_SubMessage* EdrEventMessage::mutable_msg(int index) {
  // @@protoc_insertion_point(field_mutable:EdrEventMessage.msg)
  return _impl_.msg_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EdrEventMessage_SubMessage >*
EdrEventMessage::mutable_msg() {
  // @@protoc_insertion_point(field_mutable_list:EdrEventMessage.msg)
  return &_impl_.msg_;
}
inline const ::EdrEventMessage_SubMessage& EdrEventMessage::_internal_msg(int index) const {
  return _impl_.msg_.Get(index);
}
inline const ::EdrEventMessage_SubMessage& EdrEventMessage::msg(int index) const {
  // @@protoc_insertion_point(field_get:EdrEventMessage.msg)
  return _internal_msg(index);
}
inline ::EdrEventMessage_SubMessage* EdrEventMessage::_internal_add_msg() {
  return _impl_.msg_.Add();
}
inline ::EdrEventMessage_SubMessage* EdrEventMessage::add_msg() {
  ::EdrEventMessage_SubMessage* _add = _internal_add_msg();
  // @@protoc_insertion_point(field_add:EdrEventMessage.msg)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EdrEventMessage_SubMessage >&
EdrEventMessage::msg() const {
  // @@protoc_insertion_point(field_list:EdrEventMessage.msg)
  return _impl_.msg_;
}

// -------------------------------------------------------------------

// ProcessStart

// int32 UtcTime = 1;
inline void ProcessStart::clear_utctime() {
  _impl_.utctime_ = 0;
}
inline int32_t ProcessStart::_internal_utctime() const {
  return _impl_.utctime_;
}
inline int32_t ProcessStart::utctime() const {
  // @@protoc_insertion_point(field_get:ProcessStart.UtcTime)
  return _internal_utctime();
}
inline void ProcessStart::_internal_set_utctime(int32_t value) {
  
  _impl_.utctime_ = value;
}
inline void ProcessStart::set_utctime(int32_t value) {
  _internal_set_utctime(value);
  // @@protoc_insertion_point(field_set:ProcessStart.UtcTime)
}

// int32 ProcessId = 2;
inline void ProcessStart::clear_processid() {
  _impl_.processid_ = 0;
}
inline int32_t ProcessStart::_internal_processid() const {
  return _impl_.processid_;
}
inline int32_t ProcessStart::processid() const {
  // @@protoc_insertion_point(field_get:ProcessStart.ProcessId)
  return _internal_processid();
}
inline void ProcessStart::_internal_set_processid(int32_t value) {
  
  _impl_.processid_ = value;
}
inline void ProcessStart::set_processid(int32_t value) {
  _internal_set_processid(value);
  // @@protoc_insertion_point(field_set:ProcessStart.ProcessId)
}

// string ImagePath = 3;
inline void ProcessStart::clear_imagepath() {
  _impl_.imagepath_.ClearToEmpty();
}
inline const std::string& ProcessStart::imagepath() const {
  // @@protoc_insertion_point(field_get:ProcessStart.ImagePath)
  return _internal_imagepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_imagepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.imagepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.ImagePath)
}
inline std::string* ProcessStart::mutable_imagepath() {
  std::string* _s = _internal_mutable_imagepath();
  // @@protoc_insertion_point(field_mutable:ProcessStart.ImagePath)
  return _s;
}
inline const std::string& ProcessStart::_internal_imagepath() const {
  return _impl_.imagepath_.Get();
}
inline void ProcessStart::_internal_set_imagepath(const std::string& value) {
  
  _impl_.imagepath_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_imagepath() {
  
  return _impl_.imagepath_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_imagepath() {
  // @@protoc_insertion_point(field_release:ProcessStart.ImagePath)
  return _impl_.imagepath_.Release();
}
inline void ProcessStart::set_allocated_imagepath(std::string* imagepath) {
  if (imagepath != nullptr) {
    
  } else {
    
  }
  _impl_.imagepath_.SetAllocated(imagepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.imagepath_.IsDefault()) {
    _impl_.imagepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.ImagePath)
}

// string Hash = 4;
inline void ProcessStart::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& ProcessStart::hash() const {
  // @@protoc_insertion_point(field_get:ProcessStart.Hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.Hash)
}
inline std::string* ProcessStart::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:ProcessStart.Hash)
  return _s;
}
inline const std::string& ProcessStart::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void ProcessStart::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_hash() {
  // @@protoc_insertion_point(field_release:ProcessStart.Hash)
  return _impl_.hash_.Release();
}
inline void ProcessStart::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.Hash)
}

// string Company = 5;
inline void ProcessStart::clear_company() {
  _impl_.company_.ClearToEmpty();
}
inline const std::string& ProcessStart::company() const {
  // @@protoc_insertion_point(field_get:ProcessStart.Company)
  return _internal_company();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_company(ArgT0&& arg0, ArgT... args) {
 
 _impl_.company_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.Company)
}
inline std::string* ProcessStart::mutable_company() {
  std::string* _s = _internal_mutable_company();
  // @@protoc_insertion_point(field_mutable:ProcessStart.Company)
  return _s;
}
inline const std::string& ProcessStart::_internal_company() const {
  return _impl_.company_.Get();
}
inline void ProcessStart::_internal_set_company(const std::string& value) {
  
  _impl_.company_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_company() {
  
  return _impl_.company_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_company() {
  // @@protoc_insertion_point(field_release:ProcessStart.Company)
  return _impl_.company_.Release();
}
inline void ProcessStart::set_allocated_company(std::string* company) {
  if (company != nullptr) {
    
  } else {
    
  }
  _impl_.company_.SetAllocated(company, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.company_.IsDefault()) {
    _impl_.company_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.Company)
}

// string Product = 6;
inline void ProcessStart::clear_product() {
  _impl_.product_.ClearToEmpty();
}
inline const std::string& ProcessStart::product() const {
  // @@protoc_insertion_point(field_get:ProcessStart.Product)
  return _internal_product();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_product(ArgT0&& arg0, ArgT... args) {
 
 _impl_.product_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.Product)
}
inline std::string* ProcessStart::mutable_product() {
  std::string* _s = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:ProcessStart.Product)
  return _s;
}
inline const std::string& ProcessStart::_internal_product() const {
  return _impl_.product_.Get();
}
inline void ProcessStart::_internal_set_product(const std::string& value) {
  
  _impl_.product_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_product() {
  
  return _impl_.product_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_product() {
  // @@protoc_insertion_point(field_release:ProcessStart.Product)
  return _impl_.product_.Release();
}
inline void ProcessStart::set_allocated_product(std::string* product) {
  if (product != nullptr) {
    
  } else {
    
  }
  _impl_.product_.SetAllocated(product, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_.IsDefault()) {
    _impl_.product_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.Product)
}

// string OriginalFile = 7;
inline void ProcessStart::clear_originalfile() {
  _impl_.originalfile_.ClearToEmpty();
}
inline const std::string& ProcessStart::originalfile() const {
  // @@protoc_insertion_point(field_get:ProcessStart.OriginalFile)
  return _internal_originalfile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_originalfile(ArgT0&& arg0, ArgT... args) {
 
 _impl_.originalfile_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.OriginalFile)
}
inline std::string* ProcessStart::mutable_originalfile() {
  std::string* _s = _internal_mutable_originalfile();
  // @@protoc_insertion_point(field_mutable:ProcessStart.OriginalFile)
  return _s;
}
inline const std::string& ProcessStart::_internal_originalfile() const {
  return _impl_.originalfile_.Get();
}
inline void ProcessStart::_internal_set_originalfile(const std::string& value) {
  
  _impl_.originalfile_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_originalfile() {
  
  return _impl_.originalfile_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_originalfile() {
  // @@protoc_insertion_point(field_release:ProcessStart.OriginalFile)
  return _impl_.originalfile_.Release();
}
inline void ProcessStart::set_allocated_originalfile(std::string* originalfile) {
  if (originalfile != nullptr) {
    
  } else {
    
  }
  _impl_.originalfile_.SetAllocated(originalfile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalfile_.IsDefault()) {
    _impl_.originalfile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.OriginalFile)
}

// string User = 8;
inline void ProcessStart::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& ProcessStart::user() const {
  // @@protoc_insertion_point(field_get:ProcessStart.User)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.User)
}
inline std::string* ProcessStart::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:ProcessStart.User)
  return _s;
}
inline const std::string& ProcessStart::_internal_user() const {
  return _impl_.user_.Get();
}
inline void ProcessStart::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_user() {
  // @@protoc_insertion_point(field_release:ProcessStart.User)
  return _impl_.user_.Release();
}
inline void ProcessStart::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.User)
}

// string SID = 9;
inline void ProcessStart::clear_sid() {
  _impl_.sid_.ClearToEmpty();
}
inline const std::string& ProcessStart::sid() const {
  // @@protoc_insertion_point(field_get:ProcessStart.SID)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.SID)
}
inline std::string* ProcessStart::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:ProcessStart.SID)
  return _s;
}
inline const std::string& ProcessStart::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void ProcessStart::_internal_set_sid(const std::string& value) {
  
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_sid() {
  
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_sid() {
  // @@protoc_insertion_point(field_release:ProcessStart.SID)
  return _impl_.sid_.Release();
}
inline void ProcessStart::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.SID)
}

// string CommandLine = 10;
inline void ProcessStart::clear_commandline() {
  _impl_.commandline_.ClearToEmpty();
}
inline const std::string& ProcessStart::commandline() const {
  // @@protoc_insertion_point(field_get:ProcessStart.CommandLine)
  return _internal_commandline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_commandline(ArgT0&& arg0, ArgT... args) {
 
 _impl_.commandline_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.CommandLine)
}
inline std::string* ProcessStart::mutable_commandline() {
  std::string* _s = _internal_mutable_commandline();
  // @@protoc_insertion_point(field_mutable:ProcessStart.CommandLine)
  return _s;
}
inline const std::string& ProcessStart::_internal_commandline() const {
  return _impl_.commandline_.Get();
}
inline void ProcessStart::_internal_set_commandline(const std::string& value) {
  
  _impl_.commandline_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_commandline() {
  
  return _impl_.commandline_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_commandline() {
  // @@protoc_insertion_point(field_release:ProcessStart.CommandLine)
  return _impl_.commandline_.Release();
}
inline void ProcessStart::set_allocated_commandline(std::string* commandline) {
  if (commandline != nullptr) {
    
  } else {
    
  }
  _impl_.commandline_.SetAllocated(commandline, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.commandline_.IsDefault()) {
    _impl_.commandline_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.CommandLine)
}

// string CurrentDirectory = 11;
inline void ProcessStart::clear_currentdirectory() {
  _impl_.currentdirectory_.ClearToEmpty();
}
inline const std::string& ProcessStart::currentdirectory() const {
  // @@protoc_insertion_point(field_get:ProcessStart.CurrentDirectory)
  return _internal_currentdirectory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_currentdirectory(ArgT0&& arg0, ArgT... args) {
 
 _impl_.currentdirectory_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.CurrentDirectory)
}
inline std::string* ProcessStart::mutable_currentdirectory() {
  std::string* _s = _internal_mutable_currentdirectory();
  // @@protoc_insertion_point(field_mutable:ProcessStart.CurrentDirectory)
  return _s;
}
inline const std::string& ProcessStart::_internal_currentdirectory() const {
  return _impl_.currentdirectory_.Get();
}
inline void ProcessStart::_internal_set_currentdirectory(const std::string& value) {
  
  _impl_.currentdirectory_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_currentdirectory() {
  
  return _impl_.currentdirectory_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_currentdirectory() {
  // @@protoc_insertion_point(field_release:ProcessStart.CurrentDirectory)
  return _impl_.currentdirectory_.Release();
}
inline void ProcessStart::set_allocated_currentdirectory(std::string* currentdirectory) {
  if (currentdirectory != nullptr) {
    
  } else {
    
  }
  _impl_.currentdirectory_.SetAllocated(currentdirectory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currentdirectory_.IsDefault()) {
    _impl_.currentdirectory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.CurrentDirectory)
}

// int32 TerminalSessionId = 12;
inline void ProcessStart::clear_terminalsessionid() {
  _impl_.terminalsessionid_ = 0;
}
inline int32_t ProcessStart::_internal_terminalsessionid() const {
  return _impl_.terminalsessionid_;
}
inline int32_t ProcessStart::terminalsessionid() const {
  // @@protoc_insertion_point(field_get:ProcessStart.TerminalSessionId)
  return _internal_terminalsessionid();
}
inline void ProcessStart::_internal_set_terminalsessionid(int32_t value) {
  
  _impl_.terminalsessionid_ = value;
}
inline void ProcessStart::set_terminalsessionid(int32_t value) {
  _internal_set_terminalsessionid(value);
  // @@protoc_insertion_point(field_set:ProcessStart.TerminalSessionId)
}

// string Signer = 13;
inline void ProcessStart::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& ProcessStart::signer() const {
  // @@protoc_insertion_point(field_get:ProcessStart.Signer)
  return _internal_signer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_signer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.Signer)
}
inline std::string* ProcessStart::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ProcessStart.Signer)
  return _s;
}
inline const std::string& ProcessStart::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void ProcessStart::_internal_set_signer(const std::string& value) {
  
  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_signer() {
  
  return _impl_.signer_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_signer() {
  // @@protoc_insertion_point(field_release:ProcessStart.Signer)
  return _impl_.signer_.Release();
}
inline void ProcessStart::set_allocated_signer(std::string* signer) {
  if (signer != nullptr) {
    
  } else {
    
  }
  _impl_.signer_.SetAllocated(signer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signer_.IsDefault()) {
    _impl_.signer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.Signer)
}

// string ProcessGuid = 14;
inline void ProcessStart::clear_processguid() {
  _impl_.processguid_.ClearToEmpty();
}
inline const std::string& ProcessStart::processguid() const {
  // @@protoc_insertion_point(field_get:ProcessStart.ProcessGuid)
  return _internal_processguid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_processguid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processguid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.ProcessGuid)
}
inline std::string* ProcessStart::mutable_processguid() {
  std::string* _s = _internal_mutable_processguid();
  // @@protoc_insertion_point(field_mutable:ProcessStart.ProcessGuid)
  return _s;
}
inline const std::string& ProcessStart::_internal_processguid() const {
  return _impl_.processguid_.Get();
}
inline void ProcessStart::_internal_set_processguid(const std::string& value) {
  
  _impl_.processguid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_processguid() {
  
  return _impl_.processguid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_processguid() {
  // @@protoc_insertion_point(field_release:ProcessStart.ProcessGuid)
  return _impl_.processguid_.Release();
}
inline void ProcessStart::set_allocated_processguid(std::string* processguid) {
  if (processguid != nullptr) {
    
  } else {
    
  }
  _impl_.processguid_.SetAllocated(processguid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processguid_.IsDefault()) {
    _impl_.processguid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.ProcessGuid)
}

// string ParentProcessGuid = 15;
inline void ProcessStart::clear_parentprocessguid() {
  _impl_.parentprocessguid_.ClearToEmpty();
}
inline const std::string& ProcessStart::parentprocessguid() const {
  // @@protoc_insertion_point(field_get:ProcessStart.ParentProcessGuid)
  return _internal_parentprocessguid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_parentprocessguid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parentprocessguid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.ParentProcessGuid)
}
inline std::string* ProcessStart::mutable_parentprocessguid() {
  std::string* _s = _internal_mutable_parentprocessguid();
  // @@protoc_insertion_point(field_mutable:ProcessStart.ParentProcessGuid)
  return _s;
}
inline const std::string& ProcessStart::_internal_parentprocessguid() const {
  return _impl_.parentprocessguid_.Get();
}
inline void ProcessStart::_internal_set_parentprocessguid(const std::string& value) {
  
  _impl_.parentprocessguid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_parentprocessguid() {
  
  return _impl_.parentprocessguid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_parentprocessguid() {
  // @@protoc_insertion_point(field_release:ProcessStart.ParentProcessGuid)
  return _impl_.parentprocessguid_.Release();
}
inline void ProcessStart::set_allocated_parentprocessguid(std::string* parentprocessguid) {
  if (parentprocessguid != nullptr) {
    
  } else {
    
  }
  _impl_.parentprocessguid_.SetAllocated(parentprocessguid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parentprocessguid_.IsDefault()) {
    _impl_.parentprocessguid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.ParentProcessGuid)
}

// string ProcFileId = 16;
inline void ProcessStart::clear_procfileid() {
  _impl_.procfileid_.ClearToEmpty();
}
inline const std::string& ProcessStart::procfileid() const {
  // @@protoc_insertion_point(field_get:ProcessStart.ProcFileId)
  return _internal_procfileid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_procfileid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.procfileid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.ProcFileId)
}
inline std::string* ProcessStart::mutable_procfileid() {
  std::string* _s = _internal_mutable_procfileid();
  // @@protoc_insertion_point(field_mutable:ProcessStart.ProcFileId)
  return _s;
}
inline const std::string& ProcessStart::_internal_procfileid() const {
  return _impl_.procfileid_.Get();
}
inline void ProcessStart::_internal_set_procfileid(const std::string& value) {
  
  _impl_.procfileid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_procfileid() {
  
  return _impl_.procfileid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_procfileid() {
  // @@protoc_insertion_point(field_release:ProcessStart.ProcFileId)
  return _impl_.procfileid_.Release();
}
inline void ProcessStart::set_allocated_procfileid(std::string* procfileid) {
  if (procfileid != nullptr) {
    
  } else {
    
  }
  _impl_.procfileid_.SetAllocated(procfileid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.procfileid_.IsDefault()) {
    _impl_.procfileid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.ProcFileId)
}

// string SignerName = 17;
inline void ProcessStart::clear_signername() {
  _impl_.signername_.ClearToEmpty();
}
inline const std::string& ProcessStart::signername() const {
  // @@protoc_insertion_point(field_get:ProcessStart.SignerName)
  return _internal_signername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_signername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.SignerName)
}
inline std::string* ProcessStart::mutable_signername() {
  std::string* _s = _internal_mutable_signername();
  // @@protoc_insertion_point(field_mutable:ProcessStart.SignerName)
  return _s;
}
inline const std::string& ProcessStart::_internal_signername() const {
  return _impl_.signername_.Get();
}
inline void ProcessStart::_internal_set_signername(const std::string& value) {
  
  _impl_.signername_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_signername() {
  
  return _impl_.signername_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_signername() {
  // @@protoc_insertion_point(field_release:ProcessStart.SignerName)
  return _impl_.signername_.Release();
}
inline void ProcessStart::set_allocated_signername(std::string* signername) {
  if (signername != nullptr) {
    
  } else {
    
  }
  _impl_.signername_.SetAllocated(signername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signername_.IsDefault()) {
    _impl_.signername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.SignerName)
}

// int32 Integrity = 18;
inline void ProcessStart::clear_integrity() {
  _impl_.integrity_ = 0;
}
inline int32_t ProcessStart::_internal_integrity() const {
  return _impl_.integrity_;
}
inline int32_t ProcessStart::integrity() const {
  // @@protoc_insertion_point(field_get:ProcessStart.Integrity)
  return _internal_integrity();
}
inline void ProcessStart::_internal_set_integrity(int32_t value) {
  
  _impl_.integrity_ = value;
}
inline void ProcessStart::set_integrity(int32_t value) {
  _internal_set_integrity(value);
  // @@protoc_insertion_point(field_set:ProcessStart.Integrity)
}

// int32 CreateTime = 19;
inline void ProcessStart::clear_createtime() {
  _impl_.createtime_ = 0;
}
inline int32_t ProcessStart::_internal_createtime() const {
  return _impl_.createtime_;
}
inline int32_t ProcessStart::createtime() const {
  // @@protoc_insertion_point(field_get:ProcessStart.CreateTime)
  return _internal_createtime();
}
inline void ProcessStart::_internal_set_createtime(int32_t value) {
  
  _impl_.createtime_ = value;
}
inline void ProcessStart::set_createtime(int32_t value) {
  _internal_set_createtime(value);
  // @@protoc_insertion_point(field_set:ProcessStart.CreateTime)
}

// int32 FileSize = 20;
inline void ProcessStart::clear_filesize() {
  _impl_.filesize_ = 0;
}
inline int32_t ProcessStart::_internal_filesize() const {
  return _impl_.filesize_;
}
inline int32_t ProcessStart::filesize() const {
  // @@protoc_insertion_point(field_get:ProcessStart.FileSize)
  return _internal_filesize();
}
inline void ProcessStart::_internal_set_filesize(int32_t value) {
  
  _impl_.filesize_ = value;
}
inline void ProcessStart::set_filesize(int32_t value) {
  _internal_set_filesize(value);
  // @@protoc_insertion_point(field_set:ProcessStart.FileSize)
}

// int32 SignStatus = 21;
inline void ProcessStart::clear_signstatus() {
  _impl_.signstatus_ = 0;
}
inline int32_t ProcessStart::_internal_signstatus() const {
  return _impl_.signstatus_;
}
inline int32_t ProcessStart::signstatus() const {
  // @@protoc_insertion_point(field_get:ProcessStart.SignStatus)
  return _internal_signstatus();
}
inline void ProcessStart::_internal_set_signstatus(int32_t value) {
  
  _impl_.signstatus_ = value;
}
inline void ProcessStart::set_signstatus(int32_t value) {
  _internal_set_signstatus(value);
  // @@protoc_insertion_point(field_set:ProcessStart.SignStatus)
}

// string fileguid = 22;
inline void ProcessStart::clear_fileguid() {
  _impl_.fileguid_.ClearToEmpty();
}
inline const std::string& ProcessStart::fileguid() const {
  // @@protoc_insertion_point(field_get:ProcessStart.fileguid)
  return _internal_fileguid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessStart::set_fileguid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fileguid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcessStart.fileguid)
}
inline std::string* ProcessStart::mutable_fileguid() {
  std::string* _s = _internal_mutable_fileguid();
  // @@protoc_insertion_point(field_mutable:ProcessStart.fileguid)
  return _s;
}
inline const std::string& ProcessStart::_internal_fileguid() const {
  return _impl_.fileguid_.Get();
}
inline void ProcessStart::_internal_set_fileguid(const std::string& value) {
  
  _impl_.fileguid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessStart::_internal_mutable_fileguid() {
  
  return _impl_.fileguid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessStart::release_fileguid() {
  // @@protoc_insertion_point(field_release:ProcessStart.fileguid)
  return _impl_.fileguid_.Release();
}
inline void ProcessStart::set_allocated_fileguid(std::string* fileguid) {
  if (fileguid != nullptr) {
    
  } else {
    
  }
  _impl_.fileguid_.SetAllocated(fileguid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileguid_.IsDefault()) {
    _impl_.fileguid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcessStart.fileguid)
}

// int32 StartType = 23;
inline void ProcessStart::clear_starttype() {
  _impl_.starttype_ = 0;
}
inline int32_t ProcessStart::_internal_starttype() const {
  return _impl_.starttype_;
}
inline int32_t ProcessStart::starttype() const {
  // @@protoc_insertion_point(field_get:ProcessStart.StartType)
  return _internal_starttype();
}
inline void ProcessStart::_internal_set_starttype(int32_t value) {
  
  _impl_.starttype_ = value;
}
inline void ProcessStart::set_starttype(int32_t value) {
  _internal_set_starttype(value);
  // @@protoc_insertion_point(field_set:ProcessStart.StartType)
}

// -------------------------------------------------------------------

// NetConEvent

// int32 UtcTime = 1;
inline void NetConEvent::clear_utctime() {
  _impl_.utctime_ = 0;
}
inline int32_t NetConEvent::_internal_utctime() const {
  return _impl_.utctime_;
}
inline int32_t NetConEvent::utctime() const {
  // @@protoc_insertion_point(field_get:NetConEvent.UtcTime)
  return _internal_utctime();
}
inline void NetConEvent::_internal_set_utctime(int32_t value) {
  
  _impl_.utctime_ = value;
}
inline void NetConEvent::set_utctime(int32_t value) {
  _internal_set_utctime(value);
  // @@protoc_insertion_point(field_set:NetConEvent.UtcTime)
}

// string ProcessGuid = 2;
inline void NetConEvent::clear_processguid() {
  _impl_.processguid_.ClearToEmpty();
}
inline const std::string& NetConEvent::processguid() const {
  // @@protoc_insertion_point(field_get:NetConEvent.ProcessGuid)
  return _internal_processguid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetConEvent::set_processguid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processguid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NetConEvent.ProcessGuid)
}
inline std::string* NetConEvent::mutable_processguid() {
  std::string* _s = _internal_mutable_processguid();
  // @@protoc_insertion_point(field_mutable:NetConEvent.ProcessGuid)
  return _s;
}
inline const std::string& NetConEvent::_internal_processguid() const {
  return _impl_.processguid_.Get();
}
inline void NetConEvent::_internal_set_processguid(const std::string& value) {
  
  _impl_.processguid_.Set(value, GetArenaForAllocation());
}
inline std::string* NetConEvent::_internal_mutable_processguid() {
  
  return _impl_.processguid_.Mutable(GetArenaForAllocation());
}
inline std::string* NetConEvent::release_processguid() {
  // @@protoc_insertion_point(field_release:NetConEvent.ProcessGuid)
  return _impl_.processguid_.Release();
}
inline void NetConEvent::set_allocated_processguid(std::string* processguid) {
  if (processguid != nullptr) {
    
  } else {
    
  }
  _impl_.processguid_.SetAllocated(processguid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processguid_.IsDefault()) {
    _impl_.processguid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetConEvent.ProcessGuid)
}

// int32 Protocol = 3;
inline void NetConEvent::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline int32_t NetConEvent::_internal_protocol() const {
  return _impl_.protocol_;
}
inline int32_t NetConEvent::protocol() const {
  // @@protoc_insertion_point(field_get:NetConEvent.Protocol)
  return _internal_protocol();
}
inline void NetConEvent::_internal_set_protocol(int32_t value) {
  
  _impl_.protocol_ = value;
}
inline void NetConEvent::set_protocol(int32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:NetConEvent.Protocol)
}

// fixed32 SourceIp = 4;
inline void NetConEvent::clear_sourceip() {
  _impl_.sourceip_ = 0u;
}
inline uint32_t NetConEvent::_internal_sourceip() const {
  return _impl_.sourceip_;
}
inline uint32_t NetConEvent::sourceip() const {
  // @@protoc_insertion_point(field_get:NetConEvent.SourceIp)
  return _internal_sourceip();
}
inline void NetConEvent::_internal_set_sourceip(uint32_t value) {
  
  _impl_.sourceip_ = value;
}
inline void NetConEvent::set_sourceip(uint32_t value) {
  _internal_set_sourceip(value);
  // @@protoc_insertion_point(field_set:NetConEvent.SourceIp)
}

// fixed32 SourcePort = 5;
inline void NetConEvent::clear_sourceport() {
  _impl_.sourceport_ = 0u;
}
inline uint32_t NetConEvent::_internal_sourceport() const {
  return _impl_.sourceport_;
}
inline uint32_t NetConEvent::sourceport() const {
  // @@protoc_insertion_point(field_get:NetConEvent.SourcePort)
  return _internal_sourceport();
}
inline void NetConEvent::_internal_set_sourceport(uint32_t value) {
  
  _impl_.sourceport_ = value;
}
inline void NetConEvent::set_sourceport(uint32_t value) {
  _internal_set_sourceport(value);
  // @@protoc_insertion_point(field_set:NetConEvent.SourcePort)
}

// fixed32 DestinationIp = 6;
inline void NetConEvent::clear_destinationip() {
  _impl_.destinationip_ = 0u;
}
inline uint32_t NetConEvent::_internal_destinationip() const {
  return _impl_.destinationip_;
}
inline uint32_t NetConEvent::destinationip() const {
  // @@protoc_insertion_point(field_get:NetConEvent.DestinationIp)
  return _internal_destinationip();
}
inline void NetConEvent::_internal_set_destinationip(uint32_t value) {
  
  _impl_.destinationip_ = value;
}
inline void NetConEvent::set_destinationip(uint32_t value) {
  _internal_set_destinationip(value);
  // @@protoc_insertion_point(field_set:NetConEvent.DestinationIp)
}

// fixed32 DestinationPort = 7;
inline void NetConEvent::clear_destinationport() {
  _impl_.destinationport_ = 0u;
}
inline uint32_t NetConEvent::_internal_destinationport() const {
  return _impl_.destinationport_;
}
inline uint32_t NetConEvent::destinationport() const {
  // @@protoc_insertion_point(field_get:NetConEvent.DestinationPort)
  return _internal_destinationport();
}
inline void NetConEvent::_internal_set_destinationport(uint32_t value) {
  
  _impl_.destinationport_ = value;
}
inline void NetConEvent::set_destinationport(uint32_t value) {
  _internal_set_destinationport(value);
  // @@protoc_insertion_point(field_set:NetConEvent.DestinationPort)
}

// -------------------------------------------------------------------

// CreateFileEvent

// int32 UtcTime = 1;
inline void CreateFileEvent::clear_utctime() {
  _impl_.utctime_ = 0;
}
inline int32_t CreateFileEvent::_internal_utctime() const {
  return _impl_.utctime_;
}
inline int32_t CreateFileEvent::utctime() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.UtcTime)
  return _internal_utctime();
}
inline void CreateFileEvent::_internal_set_utctime(int32_t value) {
  
  _impl_.utctime_ = value;
}
inline void CreateFileEvent::set_utctime(int32_t value) {
  _internal_set_utctime(value);
  // @@protoc_insertion_point(field_set:CreateFileEvent.UtcTime)
}

// string ProcessGuid = 2;
inline void CreateFileEvent::clear_processguid() {
  _impl_.processguid_.ClearToEmpty();
}
inline const std::string& CreateFileEvent::processguid() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.ProcessGuid)
  return _internal_processguid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFileEvent::set_processguid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processguid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateFileEvent.ProcessGuid)
}
inline std::string* CreateFileEvent::mutable_processguid() {
  std::string* _s = _internal_mutable_processguid();
  // @@protoc_insertion_point(field_mutable:CreateFileEvent.ProcessGuid)
  return _s;
}
inline const std::string& CreateFileEvent::_internal_processguid() const {
  return _impl_.processguid_.Get();
}
inline void CreateFileEvent::_internal_set_processguid(const std::string& value) {
  
  _impl_.processguid_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFileEvent::_internal_mutable_processguid() {
  
  return _impl_.processguid_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFileEvent::release_processguid() {
  // @@protoc_insertion_point(field_release:CreateFileEvent.ProcessGuid)
  return _impl_.processguid_.Release();
}
inline void CreateFileEvent::set_allocated_processguid(std::string* processguid) {
  if (processguid != nullptr) {
    
  } else {
    
  }
  _impl_.processguid_.SetAllocated(processguid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processguid_.IsDefault()) {
    _impl_.processguid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateFileEvent.ProcessGuid)
}

// string FileName = 3;
inline void CreateFileEvent::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& CreateFileEvent::filename() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.FileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFileEvent::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateFileEvent.FileName)
}
inline std::string* CreateFileEvent::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:CreateFileEvent.FileName)
  return _s;
}
inline const std::string& CreateFileEvent::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void CreateFileEvent::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFileEvent::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFileEvent::release_filename() {
  // @@protoc_insertion_point(field_release:CreateFileEvent.FileName)
  return _impl_.filename_.Release();
}
inline void CreateFileEvent::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateFileEvent.FileName)
}

// int32 CreateTime = 4;
inline void CreateFileEvent::clear_createtime() {
  _impl_.createtime_ = 0;
}
inline int32_t CreateFileEvent::_internal_createtime() const {
  return _impl_.createtime_;
}
inline int32_t CreateFileEvent::createtime() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.CreateTime)
  return _internal_createtime();
}
inline void CreateFileEvent::_internal_set_createtime(int32_t value) {
  
  _impl_.createtime_ = value;
}
inline void CreateFileEvent::set_createtime(int32_t value) {
  _internal_set_createtime(value);
  // @@protoc_insertion_point(field_set:CreateFileEvent.CreateTime)
}

// int32 CreateOptions = 5;
inline void CreateFileEvent::clear_createoptions() {
  _impl_.createoptions_ = 0;
}
inline int32_t CreateFileEvent::_internal_createoptions() const {
  return _impl_.createoptions_;
}
inline int32_t CreateFileEvent::createoptions() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.CreateOptions)
  return _internal_createoptions();
}
inline void CreateFileEvent::_internal_set_createoptions(int32_t value) {
  
  _impl_.createoptions_ = value;
}
inline void CreateFileEvent::set_createoptions(int32_t value) {
  _internal_set_createoptions(value);
  // @@protoc_insertion_point(field_set:CreateFileEvent.CreateOptions)
}

// int32 DesiredAccess = 6;
inline void CreateFileEvent::clear_desiredaccess() {
  _impl_.desiredaccess_ = 0;
}
inline int32_t CreateFileEvent::_internal_desiredaccess() const {
  return _impl_.desiredaccess_;
}
inline int32_t CreateFileEvent::desiredaccess() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.DesiredAccess)
  return _internal_desiredaccess();
}
inline void CreateFileEvent::_internal_set_desiredaccess(int32_t value) {
  
  _impl_.desiredaccess_ = value;
}
inline void CreateFileEvent::set_desiredaccess(int32_t value) {
  _internal_set_desiredaccess(value);
  // @@protoc_insertion_point(field_set:CreateFileEvent.DesiredAccess)
}

// string FileID = 7;
inline void CreateFileEvent::clear_fileid() {
  _impl_.fileid_.ClearToEmpty();
}
inline const std::string& CreateFileEvent::fileid() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.FileID)
  return _internal_fileid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFileEvent::set_fileid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fileid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateFileEvent.FileID)
}
inline std::string* CreateFileEvent::mutable_fileid() {
  std::string* _s = _internal_mutable_fileid();
  // @@protoc_insertion_point(field_mutable:CreateFileEvent.FileID)
  return _s;
}
inline const std::string& CreateFileEvent::_internal_fileid() const {
  return _impl_.fileid_.Get();
}
inline void CreateFileEvent::_internal_set_fileid(const std::string& value) {
  
  _impl_.fileid_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFileEvent::_internal_mutable_fileid() {
  
  return _impl_.fileid_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFileEvent::release_fileid() {
  // @@protoc_insertion_point(field_release:CreateFileEvent.FileID)
  return _impl_.fileid_.Release();
}
inline void CreateFileEvent::set_allocated_fileid(std::string* fileid) {
  if (fileid != nullptr) {
    
  } else {
    
  }
  _impl_.fileid_.SetAllocated(fileid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileid_.IsDefault()) {
    _impl_.fileid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateFileEvent.FileID)
}

// int32 FileSize = 8;
inline void CreateFileEvent::clear_filesize() {
  _impl_.filesize_ = 0;
}
inline int32_t CreateFileEvent::_internal_filesize() const {
  return _impl_.filesize_;
}
inline int32_t CreateFileEvent::filesize() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.FileSize)
  return _internal_filesize();
}
inline void CreateFileEvent::_internal_set_filesize(int32_t value) {
  
  _impl_.filesize_ = value;
}
inline void CreateFileEvent::set_filesize(int32_t value) {
  _internal_set_filesize(value);
  // @@protoc_insertion_point(field_set:CreateFileEvent.FileSize)
}

// int32 SignStatus = 9;
inline void CreateFileEvent::clear_signstatus() {
  _impl_.signstatus_ = 0;
}
inline int32_t CreateFileEvent::_internal_signstatus() const {
  return _impl_.signstatus_;
}
inline int32_t CreateFileEvent::signstatus() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.SignStatus)
  return _internal_signstatus();
}
inline void CreateFileEvent::_internal_set_signstatus(int32_t value) {
  
  _impl_.signstatus_ = value;
}
inline void CreateFileEvent::set_signstatus(int32_t value) {
  _internal_set_signstatus(value);
  // @@protoc_insertion_point(field_set:CreateFileEvent.SignStatus)
}

// string FileHash = 10;
inline void CreateFileEvent::clear_filehash() {
  _impl_.filehash_.ClearToEmpty();
}
inline const std::string& CreateFileEvent::filehash() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.FileHash)
  return _internal_filehash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFileEvent::set_filehash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filehash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateFileEvent.FileHash)
}
inline std::string* CreateFileEvent::mutable_filehash() {
  std::string* _s = _internal_mutable_filehash();
  // @@protoc_insertion_point(field_mutable:CreateFileEvent.FileHash)
  return _s;
}
inline const std::string& CreateFileEvent::_internal_filehash() const {
  return _impl_.filehash_.Get();
}
inline void CreateFileEvent::_internal_set_filehash(const std::string& value) {
  
  _impl_.filehash_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFileEvent::_internal_mutable_filehash() {
  
  return _impl_.filehash_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFileEvent::release_filehash() {
  // @@protoc_insertion_point(field_release:CreateFileEvent.FileHash)
  return _impl_.filehash_.Release();
}
inline void CreateFileEvent::set_allocated_filehash(std::string* filehash) {
  if (filehash != nullptr) {
    
  } else {
    
  }
  _impl_.filehash_.SetAllocated(filehash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filehash_.IsDefault()) {
    _impl_.filehash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateFileEvent.FileHash)
}

// string Signer = 11;
inline void CreateFileEvent::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& CreateFileEvent::signer() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.Signer)
  return _internal_signer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFileEvent::set_signer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateFileEvent.Signer)
}
inline std::string* CreateFileEvent::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:CreateFileEvent.Signer)
  return _s;
}
inline const std::string& CreateFileEvent::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void CreateFileEvent::_internal_set_signer(const std::string& value) {
  
  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFileEvent::_internal_mutable_signer() {
  
  return _impl_.signer_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFileEvent::release_signer() {
  // @@protoc_insertion_point(field_release:CreateFileEvent.Signer)
  return _impl_.signer_.Release();
}
inline void CreateFileEvent::set_allocated_signer(std::string* signer) {
  if (signer != nullptr) {
    
  } else {
    
  }
  _impl_.signer_.SetAllocated(signer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signer_.IsDefault()) {
    _impl_.signer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateFileEvent.Signer)
}

// string SignerName = 12;
inline void CreateFileEvent::clear_signername() {
  _impl_.signername_.ClearToEmpty();
}
inline const std::string& CreateFileEvent::signername() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.SignerName)
  return _internal_signername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFileEvent::set_signername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateFileEvent.SignerName)
}
inline std::string* CreateFileEvent::mutable_signername() {
  std::string* _s = _internal_mutable_signername();
  // @@protoc_insertion_point(field_mutable:CreateFileEvent.SignerName)
  return _s;
}
inline const std::string& CreateFileEvent::_internal_signername() const {
  return _impl_.signername_.Get();
}
inline void CreateFileEvent::_internal_set_signername(const std::string& value) {
  
  _impl_.signername_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFileEvent::_internal_mutable_signername() {
  
  return _impl_.signername_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFileEvent::release_signername() {
  // @@protoc_insertion_point(field_release:CreateFileEvent.SignerName)
  return _impl_.signername_.Release();
}
inline void CreateFileEvent::set_allocated_signername(std::string* signername) {
  if (signername != nullptr) {
    
  } else {
    
  }
  _impl_.signername_.SetAllocated(signername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signername_.IsDefault()) {
    _impl_.signername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateFileEvent.SignerName)
}

// string CompanyName = 13;
inline void CreateFileEvent::clear_companyname() {
  _impl_.companyname_.ClearToEmpty();
}
inline const std::string& CreateFileEvent::companyname() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.CompanyName)
  return _internal_companyname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFileEvent::set_companyname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.companyname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateFileEvent.CompanyName)
}
inline std::string* CreateFileEvent::mutable_companyname() {
  std::string* _s = _internal_mutable_companyname();
  // @@protoc_insertion_point(field_mutable:CreateFileEvent.CompanyName)
  return _s;
}
inline const std::string& CreateFileEvent::_internal_companyname() const {
  return _impl_.companyname_.Get();
}
inline void CreateFileEvent::_internal_set_companyname(const std::string& value) {
  
  _impl_.companyname_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFileEvent::_internal_mutable_companyname() {
  
  return _impl_.companyname_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFileEvent::release_companyname() {
  // @@protoc_insertion_point(field_release:CreateFileEvent.CompanyName)
  return _impl_.companyname_.Release();
}
inline void CreateFileEvent::set_allocated_companyname(std::string* companyname) {
  if (companyname != nullptr) {
    
  } else {
    
  }
  _impl_.companyname_.SetAllocated(companyname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.companyname_.IsDefault()) {
    _impl_.companyname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateFileEvent.CompanyName)
}

// string OriginalFile = 14;
inline void CreateFileEvent::clear_originalfile() {
  _impl_.originalfile_.ClearToEmpty();
}
inline const std::string& CreateFileEvent::originalfile() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.OriginalFile)
  return _internal_originalfile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFileEvent::set_originalfile(ArgT0&& arg0, ArgT... args) {
 
 _impl_.originalfile_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateFileEvent.OriginalFile)
}
inline std::string* CreateFileEvent::mutable_originalfile() {
  std::string* _s = _internal_mutable_originalfile();
  // @@protoc_insertion_point(field_mutable:CreateFileEvent.OriginalFile)
  return _s;
}
inline const std::string& CreateFileEvent::_internal_originalfile() const {
  return _impl_.originalfile_.Get();
}
inline void CreateFileEvent::_internal_set_originalfile(const std::string& value) {
  
  _impl_.originalfile_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFileEvent::_internal_mutable_originalfile() {
  
  return _impl_.originalfile_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFileEvent::release_originalfile() {
  // @@protoc_insertion_point(field_release:CreateFileEvent.OriginalFile)
  return _impl_.originalfile_.Release();
}
inline void CreateFileEvent::set_allocated_originalfile(std::string* originalfile) {
  if (originalfile != nullptr) {
    
  } else {
    
  }
  _impl_.originalfile_.SetAllocated(originalfile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalfile_.IsDefault()) {
    _impl_.originalfile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateFileEvent.OriginalFile)
}

// string ProductName = 15;
inline void CreateFileEvent::clear_productname() {
  _impl_.productname_.ClearToEmpty();
}
inline const std::string& CreateFileEvent::productname() const {
  // @@protoc_insertion_point(field_get:CreateFileEvent.ProductName)
  return _internal_productname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFileEvent::set_productname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.productname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateFileEvent.ProductName)
}
inline std::string* CreateFileEvent::mutable_productname() {
  std::string* _s = _internal_mutable_productname();
  // @@protoc_insertion_point(field_mutable:CreateFileEvent.ProductName)
  return _s;
}
inline const std::string& CreateFileEvent::_internal_productname() const {
  return _impl_.productname_.Get();
}
inline void CreateFileEvent::_internal_set_productname(const std::string& value) {
  
  _impl_.productname_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFileEvent::_internal_mutable_productname() {
  
  return _impl_.productname_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFileEvent::release_productname() {
  // @@protoc_insertion_point(field_release:CreateFileEvent.ProductName)
  return _impl_.productname_.Release();
}
inline void CreateFileEvent::set_allocated_productname(std::string* productname) {
  if (productname != nullptr) {
    
  } else {
    
  }
  _impl_.productname_.SetAllocated(productname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productname_.IsDefault()) {
    _impl_.productname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateFileEvent.ProductName)
}

// -------------------------------------------------------------------

// ReNameFileEvent

// int32 UtcTime = 1;
inline void ReNameFileEvent::clear_utctime() {
  _impl_.utctime_ = 0;
}
inline int32_t ReNameFileEvent::_internal_utctime() const {
  return _impl_.utctime_;
}
inline int32_t ReNameFileEvent::utctime() const {
  // @@protoc_insertion_point(field_get:ReNameFileEvent.UtcTime)
  return _internal_utctime();
}
inline void ReNameFileEvent::_internal_set_utctime(int32_t value) {
  
  _impl_.utctime_ = value;
}
inline void ReNameFileEvent::set_utctime(int32_t value) {
  _internal_set_utctime(value);
  // @@protoc_insertion_point(field_set:ReNameFileEvent.UtcTime)
}

// string ProcessGuid = 2;
inline void ReNameFileEvent::clear_processguid() {
  _impl_.processguid_.ClearToEmpty();
}
inline const std::string& ReNameFileEvent::processguid() const {
  // @@protoc_insertion_point(field_get:ReNameFileEvent.ProcessGuid)
  return _internal_processguid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReNameFileEvent::set_processguid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processguid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReNameFileEvent.ProcessGuid)
}
inline std::string* ReNameFileEvent::mutable_processguid() {
  std::string* _s = _internal_mutable_processguid();
  // @@protoc_insertion_point(field_mutable:ReNameFileEvent.ProcessGuid)
  return _s;
}
inline const std::string& ReNameFileEvent::_internal_processguid() const {
  return _impl_.processguid_.Get();
}
inline void ReNameFileEvent::_internal_set_processguid(const std::string& value) {
  
  _impl_.processguid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReNameFileEvent::_internal_mutable_processguid() {
  
  return _impl_.processguid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReNameFileEvent::release_processguid() {
  // @@protoc_insertion_point(field_release:ReNameFileEvent.ProcessGuid)
  return _impl_.processguid_.Release();
}
inline void ReNameFileEvent::set_allocated_processguid(std::string* processguid) {
  if (processguid != nullptr) {
    
  } else {
    
  }
  _impl_.processguid_.SetAllocated(processguid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processguid_.IsDefault()) {
    _impl_.processguid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReNameFileEvent.ProcessGuid)
}

// string OldPath = 3;
inline void ReNameFileEvent::clear_oldpath() {
  _impl_.oldpath_.ClearToEmpty();
}
inline const std::string& ReNameFileEvent::oldpath() const {
  // @@protoc_insertion_point(field_get:ReNameFileEvent.OldPath)
  return _internal_oldpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReNameFileEvent::set_oldpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.oldpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReNameFileEvent.OldPath)
}
inline std::string* ReNameFileEvent::mutable_oldpath() {
  std::string* _s = _internal_mutable_oldpath();
  // @@protoc_insertion_point(field_mutable:ReNameFileEvent.OldPath)
  return _s;
}
inline const std::string& ReNameFileEvent::_internal_oldpath() const {
  return _impl_.oldpath_.Get();
}
inline void ReNameFileEvent::_internal_set_oldpath(const std::string& value) {
  
  _impl_.oldpath_.Set(value, GetArenaForAllocation());
}
inline std::string* ReNameFileEvent::_internal_mutable_oldpath() {
  
  return _impl_.oldpath_.Mutable(GetArenaForAllocation());
}
inline std::string* ReNameFileEvent::release_oldpath() {
  // @@protoc_insertion_point(field_release:ReNameFileEvent.OldPath)
  return _impl_.oldpath_.Release();
}
inline void ReNameFileEvent::set_allocated_oldpath(std::string* oldpath) {
  if (oldpath != nullptr) {
    
  } else {
    
  }
  _impl_.oldpath_.SetAllocated(oldpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.oldpath_.IsDefault()) {
    _impl_.oldpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReNameFileEvent.OldPath)
}

// string NewPath = 4;
inline void ReNameFileEvent::clear_newpath() {
  _impl_.newpath_.ClearToEmpty();
}
inline const std::string& ReNameFileEvent::newpath() const {
  // @@protoc_insertion_point(field_get:ReNameFileEvent.NewPath)
  return _internal_newpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReNameFileEvent::set_newpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReNameFileEvent.NewPath)
}
inline std::string* ReNameFileEvent::mutable_newpath() {
  std::string* _s = _internal_mutable_newpath();
  // @@protoc_insertion_point(field_mutable:ReNameFileEvent.NewPath)
  return _s;
}
inline const std::string& ReNameFileEvent::_internal_newpath() const {
  return _impl_.newpath_.Get();
}
inline void ReNameFileEvent::_internal_set_newpath(const std::string& value) {
  
  _impl_.newpath_.Set(value, GetArenaForAllocation());
}
inline std::string* ReNameFileEvent::_internal_mutable_newpath() {
  
  return _impl_.newpath_.Mutable(GetArenaForAllocation());
}
inline std::string* ReNameFileEvent::release_newpath() {
  // @@protoc_insertion_point(field_release:ReNameFileEvent.NewPath)
  return _impl_.newpath_.Release();
}
inline void ReNameFileEvent::set_allocated_newpath(std::string* newpath) {
  if (newpath != nullptr) {
    
  } else {
    
  }
  _impl_.newpath_.SetAllocated(newpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newpath_.IsDefault()) {
    _impl_.newpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReNameFileEvent.NewPath)
}

// string FileSigner = 5;
inline void ReNameFileEvent::clear_filesigner() {
  _impl_.filesigner_.ClearToEmpty();
}
inline const std::string& ReNameFileEvent::filesigner() const {
  // @@protoc_insertion_point(field_get:ReNameFileEvent.FileSigner)
  return _internal_filesigner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReNameFileEvent::set_filesigner(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filesigner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReNameFileEvent.FileSigner)
}
inline std::string* ReNameFileEvent::mutable_filesigner() {
  std::string* _s = _internal_mutable_filesigner();
  // @@protoc_insertion_point(field_mutable:ReNameFileEvent.FileSigner)
  return _s;
}
inline const std::string& ReNameFileEvent::_internal_filesigner() const {
  return _impl_.filesigner_.Get();
}
inline void ReNameFileEvent::_internal_set_filesigner(const std::string& value) {
  
  _impl_.filesigner_.Set(value, GetArenaForAllocation());
}
inline std::string* ReNameFileEvent::_internal_mutable_filesigner() {
  
  return _impl_.filesigner_.Mutable(GetArenaForAllocation());
}
inline std::string* ReNameFileEvent::release_filesigner() {
  // @@protoc_insertion_point(field_release:ReNameFileEvent.FileSigner)
  return _impl_.filesigner_.Release();
}
inline void ReNameFileEvent::set_allocated_filesigner(std::string* filesigner) {
  if (filesigner != nullptr) {
    
  } else {
    
  }
  _impl_.filesigner_.SetAllocated(filesigner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesigner_.IsDefault()) {
    _impl_.filesigner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReNameFileEvent.FileSigner)
}

// string FileID = 6;
inline void ReNameFileEvent::clear_fileid() {
  _impl_.fileid_.ClearToEmpty();
}
inline const std::string& ReNameFileEvent::fileid() const {
  // @@protoc_insertion_point(field_get:ReNameFileEvent.FileID)
  return _internal_fileid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReNameFileEvent::set_fileid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fileid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReNameFileEvent.FileID)
}
inline std::string* ReNameFileEvent::mutable_fileid() {
  std::string* _s = _internal_mutable_fileid();
  // @@protoc_insertion_point(field_mutable:ReNameFileEvent.FileID)
  return _s;
}
inline const std::string& ReNameFileEvent::_internal_fileid() const {
  return _impl_.fileid_.Get();
}
inline void ReNameFileEvent::_internal_set_fileid(const std::string& value) {
  
  _impl_.fileid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReNameFileEvent::_internal_mutable_fileid() {
  
  return _impl_.fileid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReNameFileEvent::release_fileid() {
  // @@protoc_insertion_point(field_release:ReNameFileEvent.FileID)
  return _impl_.fileid_.Release();
}
inline void ReNameFileEvent::set_allocated_fileid(std::string* fileid) {
  if (fileid != nullptr) {
    
  } else {
    
  }
  _impl_.fileid_.SetAllocated(fileid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileid_.IsDefault()) {
    _impl_.fileid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReNameFileEvent.FileID)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_edr_5fevent_2eproto
